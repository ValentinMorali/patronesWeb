{"version":3,"sources":["c:/patrones/patronesSidercaWeb/Frontend/node_modules/ngx-countdown/fesm2015/ngx-countdown.js"],"names":[],"mappings":"AAAA;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DC,mJAGC;;;;;;;;;;;;;;;;CAWD,uIAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsOD,aAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgBD,iMAQC","file":"ngx-countdown.js","sourcesContent":["import { CommonModule } from '@angular/common';\nimport { Injectable, Component, ElementRef, Input, Output, EventEmitter, ChangeDetectionStrategy, ViewEncapsulation, defineInjectable, NgModule } from '@angular/core';\n\nclass Timer {\n    constructor() {\n        this.fns = [];\n        this.commands = [];\n        this.ing = false;\n    }\n    start() {\n        if (this.ing === true)\n            return;\n        this.ing = true;\n        this.nextTime = +new Date();\n        this.process();\n    }\n    process() {\n        while (this.commands.length) {\n            this.commands.shift()();\n        }\n        let diff = +new Date() - this.nextTime;\n        const count = 1 + Math.floor(diff / 100);\n        diff = 100 - diff % 100;\n        this.nextTime += 100 * count;\n        let frequency, step, i, len;\n        for (i = 0, len = this.fns.length; i < len; i += 2) {\n            frequency = this.fns[i + 1];\n            // 100/s\n            if (0 === frequency) {\n                this.fns[i](count);\n                // 1000/s\n            }\n            else {\n                // 先把末位至0，再每次加2\n                frequency += 2 * count - 1;\n                step = Math.floor(frequency / 20);\n                if (step > 0) {\n                    this.fns[i](step);\n                }\n                // 把末位还原成1\n                this.fns[i + 1] = frequency % 20 + 1;\n            }\n        }\n        if (this.ing) {\n            setTimeout(() => this.process(), diff);\n        }\n    }\n    add(fn, frequency) {\n        this.commands.push(() => {\n            this.fns.push(fn);\n            this.fns.push(frequency === 1000 ? 1 : 0);\n            this.ing = true;\n        });\n    }\n    remove(fn) {\n        this.commands.push(() => {\n            const i = this.fns.indexOf(fn);\n            if (i !== -1) {\n                this.fns.splice(i, 2);\n            }\n            this.ing = this.fns.length > 0;\n        });\n    }\n}\nTimer.decorators = [\n    { type: Injectable }\n];\n\nclass CountdownConfig {\n    constructor() {\n        this.demand = false;\n        this.leftTime = 0;\n        this.template = '$!h!时$!m!分$!s!秒';\n        this.effect = 'normal';\n        this.varRegular = /\\$\\!([\\-\\w]+)\\!/g;\n        this.clock = ['d', 100, 2, 'h', 24, 2, 'm', 60, 2, 's', 60, 2, 'u', 10, 1];\n    }\n}\nCountdownConfig.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] }\n];\nCountdownConfig.ngInjectableDef = defineInjectable({ factory: function CountdownConfig_Factory() { return new CountdownConfig(); }, token: CountdownConfig, providedIn: \"root\" });\n\nclass CountdownComponent {\n    constructor(el, timer, cog) {\n        this.el = el;\n        this.timer = timer;\n        this.cog = cog;\n        this.frequency = 1000;\n        this._notify = {};\n        this.hands = [];\n        this.left = 0;\n        this.paused = false;\n        /** 两种情况会触发：时间终止或调用 `stop()` */\n        this.stoped = false;\n        this.start = new EventEmitter();\n        this.finished = new EventEmitter();\n        this.notify = new EventEmitter();\n        this.event = new EventEmitter();\n    }\n    /** 开始，当 `demand: false` 时触发 */\n    begin() {\n        this.paused = false;\n        this.start.emit();\n        this.callEvent('start');\n    }\n    /** 重新开始 */\n    restart() {\n        if (!this.stoped)\n            this.destroy();\n        this.init();\n        this.callEvent('restart');\n    }\n    /** 停止 */\n    stop() {\n        if (this.stoped)\n            return;\n        this.stoped = true;\n        this.destroy();\n        this.callEvent('stop');\n    }\n    /** 暂停（限未终止有效） */\n    pause() {\n        if (this.stoped || this.paused)\n            return;\n        this.paused = true;\n        this.callEvent('pause');\n    }\n    /** 恢复 */\n    resume() {\n        if (this.stoped || !this.paused)\n            return;\n        this.paused = false;\n        this.callEvent('resume');\n    }\n    callEvent(action) {\n        this.event.emit({ action, left: this.left });\n    }\n    init() {\n        const me = this;\n        me.config = Object.assign({}, new CountdownConfig(), me.cog, me.config);\n        const el = me.el.nativeElement;\n        me.paused = me.config.demand;\n        me.stoped = false;\n        // 分析markup\n        const tmpl = el.innerHTML || me.config.template;\n        me.config.varRegular.lastIndex = 0;\n        el.innerHTML = tmpl.replace(me.config.varRegular, (str, type) => {\n            // 时钟频率校正.\n            if (type === 'u' || type === 's-ext')\n                me.frequency = 100;\n            // 生成hand的markup\n            let content = '';\n            if (type === 's-ext') {\n                me.hands.push({ type: 's' });\n                me.hands.push({ type: 'u' });\n                content =\n                    me.html('', 's', 'handlet') +\n                        me.html('.', '', 'digital') +\n                        me.html('', 'u', 'handlet');\n            }\n            else {\n                me.hands.push({ type: type });\n            }\n            return me.html(content, type, 'hand');\n        });\n        const clock = me.config.clock;\n        me.hands.forEach((hand) => {\n            const type = hand.type;\n            let base = 100, i;\n            hand.node = el.querySelector(`.hand-${type}`);\n            // radix, bits 初始化\n            for (i = clock.length - 3; i > -1; i -= 3) {\n                if (type === clock[i]) {\n                    break;\n                }\n                base *= clock[i + 1];\n            }\n            hand.base = base;\n            hand.radix = clock[i + 1];\n            hand.bits = clock[i + 2];\n        });\n        me.getLeft();\n        me.reflow(0, true);\n        // bind reflow to me\n        const _reflow = me.reflow;\n        me.reflow = (count = 0) => {\n            return _reflow.apply(me, [count]);\n        };\n        // 构建 notify\n        if (me.config.notify) {\n            me.config.notify.forEach((time) => {\n                if (time < 1)\n                    throw new Error(`the notify config must be a positive integer.`);\n                time = time * 1000;\n                time = time - (time % me.frequency);\n                me._notify[time] = true;\n            });\n        }\n        me.timer.add(me.reflow, me.frequency);\n        // show\n        el.style.display = 'inline';\n        this.timer.start();\n        return me;\n    }\n    destroy() {\n        this.timer.remove(this.reflow);\n        return this;\n    }\n    /**\n     * 更新时钟\n     */\n    reflow(count = 0, force = false) {\n        const me = this;\n        if (!force && (me.paused || me.stoped))\n            return;\n        me.left = me.left - me.frequency * count;\n        me.hands.forEach((hand) => {\n            hand.lastValue = hand.value;\n            hand.value = Math.floor(me.left / hand.base) % hand.radix;\n        });\n        me.repaint();\n        if (me._notify[me.left]) {\n            me.notify.emit(me.left);\n            me.callEvent('notify');\n        }\n        if (me.left < 1) {\n            me.finished.emit(0);\n            me.stoped = true;\n            me.callEvent('finished');\n            me.destroy();\n        }\n    }\n    /**\n     * 重绘时钟\n     */\n    repaint() {\n        const me = this;\n        if (me.config.repaint) {\n            me.config.repaint.apply(me);\n            return;\n        }\n        let content;\n        me.hands.forEach((hand) => {\n            if (hand.lastValue !== hand.value) {\n                content = '';\n                me.toDigitals(hand.value, hand.bits).forEach((digital) => {\n                    content += me.html(digital.toString(), '', 'digital');\n                });\n                hand.node.innerHTML = content;\n            }\n        });\n    }\n    /**\n     * 获取倒计时剩余帧数\n     */\n    getLeft() {\n        const me = this;\n        let left = me.config.leftTime * 1000;\n        const end = me.config.stopTime;\n        if (!left && end)\n            left = end - new Date().getTime();\n        me.left = left - (left % me.frequency);\n    }\n    /**\n     * 生成需要的html代码，辅助工具\n     */\n    html(con, className, type) {\n        switch (type) {\n            case 'hand':\n            case 'handlet':\n                className = type + ' hand-' + className;\n                break;\n            case 'digital':\n                if (con === '.') {\n                    className = type + ' ' + type + '-point ' + className;\n                }\n                else {\n                    className = type + ' ' + type + '-' + con + ' ' + className;\n                }\n                break;\n        }\n        return '<span class=\"' + className + '\">' + con + '</span>';\n    }\n    /**\n     * 把值转换为独立的数字形式\n     */\n    toDigitals(value, bits) {\n        value = value < 0 ? 0 : value;\n        const digitals = [];\n        // 把时、分、秒等换算成数字.\n        while (bits--) {\n            digitals[bits] = value % 10;\n            value = Math.floor(value / 10);\n        }\n        return digitals;\n    }\n    ngOnInit() {\n        this.init();\n        if (!this.config.demand)\n            this.begin();\n    }\n    ngOnDestroy() {\n        this.destroy();\n    }\n    ngOnChanges(changes) {\n        if (!changes.config.firstChange) {\n            this.restart();\n        }\n    }\n}\nCountdownComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'countdown',\n                template: `\n    <ng-content></ng-content>\n  `,\n                host: { '[class.count-down]': 'true' },\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                styles: [`\n      countdown {\n        display: none;\n      }\n    `]\n            }] }\n];\n/** @nocollapse */\nCountdownComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Timer },\n    { type: CountdownConfig }\n];\nCountdownComponent.propDecorators = {\n    config: [{ type: Input }],\n    start: [{ type: Output }],\n    finished: [{ type: Output }],\n    notify: [{ type: Output }],\n    event: [{ type: Output }]\n};\n\nclass CountdownModule {\n}\nCountdownModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CommonModule],\n                providers: [Timer],\n                declarations: [CountdownComponent],\n                exports: [CountdownComponent]\n            },] }\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CountdownConfig as ɵa, CountdownComponent, Timer, CountdownModule };\n"]}