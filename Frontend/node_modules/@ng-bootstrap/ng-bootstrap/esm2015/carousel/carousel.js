/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, EventEmitter, Inject, Input, NgZone, Output, PLATFORM_ID, QueryList, TemplateRef, HostListener } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { NgbCarouselConfig } from './carousel-config';
import { Subject, timer, BehaviorSubject, combineLatest, NEVER } from 'rxjs';
import { startWith, map, switchMap, takeUntil, distinctUntilChanged } from 'rxjs/operators';
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["tabIndex", "0", 1, "carousel", "slide"];
const _c1 = ["display"];
const _c2 = ["class", "carousel-indicators", 4, "ngIf"];
const _c3 = [1, "carousel-inner"];
const _c4 = ["class", "carousel-item", 3, "active", 4, "ngFor", "ngForOf"];
const _c5 = ["class", "carousel-control-prev", "role", "button", 3, "click", 4, "ngIf"];
const _c6 = ["class", "carousel-control-next", "role", "button", 3, "click", 4, "ngIf"];
const _c7 = [1, "carousel-indicators"];
const _c8 = [3, "id", "active", "click", 4, "ngFor", "ngForOf"];
const _c9 = [3, "id", "click"];
const _c10 = ["active"];
function NgbCarousel_ol_0_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r418 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", _c9);
    ɵngcc0.ɵɵstyling(_c10);
    ɵngcc0.ɵɵlistener("click", function NgbCarousel_ol_0_li_1_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r418); const slide_r416 = ctx.$implicit; const ctx_r417 = ɵngcc0.ɵɵnextContext(2); return ctx_r417.select(slide_r416.id, ctx_r417.NgbSlideEventSource.INDICATOR); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const slide_r416 = ctx.$implicit;
    const ctx_r415 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵclassProp(0, slide_r416.id === ctx_r415.activeId);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵproperty("id", slide_r416.id);
} }
function NgbCarousel_ol_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ol", _c7);
    ɵngcc0.ɵɵtemplate(1, NgbCarousel_ol_0_li_1_Template, 1, 1, "li", _c8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r411 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r411.slides);
} }
const _c11 = [1, "carousel-item"];
const _c12 = [3, "ngTemplateOutlet"];
function NgbCarousel_div_2_ng_template_1_Template(rf, ctx) { }
function NgbCarousel_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", _c11);
    ɵngcc0.ɵɵstyling(_c10);
    ɵngcc0.ɵɵtemplate(1, NgbCarousel_div_2_ng_template_1_Template, 0, 0, "ng-template", _c12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const slide_r419 = ctx.$implicit;
    const ctx_r412 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp(0, slide_r419.id === ctx_r412.activeId);
    ɵngcc0.ɵɵstylingApply();
    ɵngcc0.ɵɵselect(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", slide_r419.tplRef);
} }
const _c13 = ["role", "button", 1, "carousel-control-prev", 3, "click"];
const _c14 = ["aria-hidden", "true", 1, "carousel-control-prev-icon"];
const _c15 = [1, "sr-only"];
var I18N_16;
if (ngI18nClosureMode) {
    const MSG_EXTERNAL_ngb_carousel_previous$$ESM2015_CAROUSEL_CAROUSEL_JS__17 = goog.getMsg("Previous");
    I18N_16 = MSG_EXTERNAL_ngb_carousel_previous$$ESM2015_CAROUSEL_CAROUSEL_JS__17;
}
else {
    I18N_16 = ɵngcc0.ɵɵi18nLocalize("Previous");
}
function NgbCarousel_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r422 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", _c13);
    ɵngcc0.ɵɵlistener("click", function NgbCarousel_a_3_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r422); const ctx_r421 = ɵngcc0.ɵɵnextContext(); return ctx_r421.prev(ctx_r421.NgbSlideEventSource.ARROW_LEFT); });
    ɵngcc0.ɵɵelement(1, "span", _c14);
    ɵngcc0.ɵɵelementStart(2, "span", _c15);
    ɵngcc0.ɵɵi18n(3, I18N_16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
const _c18 = ["role", "button", 1, "carousel-control-next", 3, "click"];
const _c19 = ["aria-hidden", "true", 1, "carousel-control-next-icon"];
var I18N_20;
if (ngI18nClosureMode) {
    const MSG_EXTERNAL_ngb_carousel_next$$ESM2015_CAROUSEL_CAROUSEL_JS__21 = goog.getMsg("Next");
    I18N_20 = MSG_EXTERNAL_ngb_carousel_next$$ESM2015_CAROUSEL_CAROUSEL_JS__21;
}
else {
    I18N_20 = ɵngcc0.ɵɵi18nLocalize("Next");
}
function NgbCarousel_a_4_Template(rf, ctx) { if (rf & 1) {
    const _r424 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", _c18);
    ɵngcc0.ɵɵlistener("click", function NgbCarousel_a_4_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r424); const ctx_r423 = ɵngcc0.ɵɵnextContext(); return ctx_r423.next(ctx_r423.NgbSlideEventSource.ARROW_RIGHT); });
    ɵngcc0.ɵɵelement(1, "span", _c19);
    ɵngcc0.ɵɵelementStart(2, "span", _c15);
    ɵngcc0.ɵɵi18n(3, I18N_20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
let nextId = 0;
/**
 * A directive that wraps the individual carousel slide.
 */
export class NgbSlide {
    /**
     * @param {?} tplRef
     */
    constructor(tplRef) {
        this.tplRef = tplRef;
        /**
         * Slide id that must be unique for the entire document.
         *
         * If not provided, will be generated in the `ngb-slide-xx` format.
         */
        this.id = `ngb-slide-${nextId++}`;
    }
}
NgbSlide.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgbSlide, selectors: [["ng-template", "ngbSlide", ""]], factory: function NgbSlide_Factory(t) { return new (t || NgbSlide)(ɵngcc0.ɵɵdirectiveInject(TemplateRef)); }, inputs: { id: "id" } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbSlide, [{
        type: Directive,
        args: [{ selector: 'ng-template[ngbSlide]' }]
    }], function () { return [{ type: TemplateRef }]; }, { constructor: [], tplRef: [], id: [{
            type: Input
        }] });
/** @nocollapse */
NgbSlide.ctorParameters = () => [
    { type: TemplateRef }
];
NgbSlide.propDecorators = {
    id: [{ type: Input }]
};
if (false) {
    /**
     * Slide id that must be unique for the entire document.
     *
     * If not provided, will be generated in the `ngb-slide-xx` format.
     * @type {?}
     */
    NgbSlide.prototype.id;
    /** @type {?} */
    NgbSlide.prototype.tplRef;
}
/**
 * Carousel is a component to easily create and control slideshows.
 *
 * Allows to set intervals, change the way user interacts with the slides and provides a programmatic API.
 */
export class NgbCarousel {
    /**
     * @param {?} config
     * @param {?} _platformId
     * @param {?} _ngZone
     * @param {?} _cd
     */
    constructor(config, _platformId, _ngZone, _cd) {
        this._platformId = _platformId;
        this._ngZone = _ngZone;
        this._cd = _cd;
        this.NgbSlideEventSource = NgbSlideEventSource;
        this._destroy$ = new Subject();
        this._interval$ = new BehaviorSubject(0);
        this._mouseHover$ = new BehaviorSubject(false);
        this._pauseOnHover$ = new BehaviorSubject(false);
        this._pause$ = new BehaviorSubject(false);
        this._wrap$ = new BehaviorSubject(false);
        /**
         * An event emitted right after the slide transition is completed.
         *
         * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
         */
        this.slide = new EventEmitter();
        this.interval = config.interval;
        this.wrap = config.wrap;
        this.keyboard = config.keyboard;
        this.pauseOnHover = config.pauseOnHover;
        this.showNavigationArrows = config.showNavigationArrows;
        this.showNavigationIndicators = config.showNavigationIndicators;
    }
    /**
     * Time in milliseconds before the next slide is shown.
     * @param {?} value
     * @return {?}
     */
    set interval(value) {
        this._interval$.next(value);
    }
    /**
     * @return {?}
     */
    get interval() { return this._interval$.value; }
    /**
     * If `true`, will 'wrap' the carousel by switching from the last slide back to the first.
     * @param {?} value
     * @return {?}
     */
    set wrap(value) {
        this._wrap$.next(value);
    }
    /**
     * @return {?}
     */
    get wrap() { return this._wrap$.value; }
    /**
     * If `true`, will pause slide switching when mouse cursor hovers the slide.
     *
     * \@since 2.2.0
     * @param {?} value
     * @return {?}
     */
    set pauseOnHover(value) {
        this._pauseOnHover$.next(value);
    }
    /**
     * @return {?}
     */
    get pauseOnHover() { return this._pauseOnHover$.value; }
    /**
     * @return {?}
     */
    mouseEnter() {
        this._mouseHover$.next(true);
    }
    /**
     * @return {?}
     */
    mouseLeave() {
        this._mouseHover$.next(false);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // setInterval() doesn't play well with SSR and protractor,
        // so we should run it in the browser and outside Angular
        if (isPlatformBrowser(this._platformId)) {
            this._ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const hasNextSlide$ = combineLatest(this.slide.pipe(map((/**
                 * @param {?} slideEvent
                 * @return {?}
                 */
                slideEvent => slideEvent.current)), startWith(this.activeId)), this._wrap$, this.slides.changes.pipe(startWith(null)))
                    .pipe(map((/**
                 * @param {?} __0
                 * @return {?}
                 */
                ([currentSlideId, wrap]) => {
                    /** @type {?} */
                    const slideArr = this.slides.toArray();
                    /** @type {?} */
                    const currentSlideIdx = this._getSlideIdxById(currentSlideId);
                    return wrap ? slideArr.length > 1 : currentSlideIdx < slideArr.length - 1;
                })), distinctUntilChanged());
                combineLatest(this._pause$, this._pauseOnHover$, this._mouseHover$, this._interval$, hasNextSlide$)
                    .pipe(map((/**
                 * @param {?} __0
                 * @return {?}
                 */
                ([pause, pauseOnHover, mouseHover, interval, hasNextSlide]) => ((pause || (pauseOnHover && mouseHover) || !hasNextSlide) ? 0 : interval))), distinctUntilChanged(), switchMap((/**
                 * @param {?} interval
                 * @return {?}
                 */
                interval => interval > 0 ? timer(interval, interval) : NEVER)), takeUntil(this._destroy$))
                    .subscribe((/**
                 * @return {?}
                 */
                () => this._ngZone.run((/**
                 * @return {?}
                 */
                () => this.next(NgbSlideEventSource.TIMER)))));
            }));
        }
        this.slides.changes.pipe(takeUntil(this._destroy$)).subscribe((/**
         * @return {?}
         */
        () => this._cd.markForCheck()));
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        /** @type {?} */
        let activeSlide = this._getSlideById(this.activeId);
        this.activeId = activeSlide ? activeSlide.id : (this.slides.length ? this.slides.first.id : null);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() { this._destroy$.next(); }
    /**
     * Navigates to a slide with the specified identifier.
     * @param {?} slideId
     * @param {?=} source
     * @return {?}
     */
    select(slideId, source) {
        this._cycleToSelected(slideId, this._getSlideEventDirection(this.activeId, slideId), source);
    }
    /**
     * Navigates to the previous slide.
     * @param {?=} source
     * @return {?}
     */
    prev(source) {
        this._cycleToSelected(this._getPrevSlide(this.activeId), NgbSlideEventDirection.RIGHT, source);
    }
    /**
     * Navigates to the next slide.
     * @param {?=} source
     * @return {?}
     */
    next(source) {
        this._cycleToSelected(this._getNextSlide(this.activeId), NgbSlideEventDirection.LEFT, source);
    }
    /**
     * Pauses cycling through the slides.
     * @return {?}
     */
    pause() { this._pause$.next(true); }
    /**
     * Restarts cycling through the slides from left to right.
     * @return {?}
     */
    cycle() { this._pause$.next(false); }
    /**
     * @private
     * @param {?} slideIdx
     * @param {?} direction
     * @param {?=} source
     * @return {?}
     */
    _cycleToSelected(slideIdx, direction, source) {
        /** @type {?} */
        let selectedSlide = this._getSlideById(slideIdx);
        if (selectedSlide && selectedSlide.id !== this.activeId) {
            this.slide.emit({ prev: this.activeId, current: selectedSlide.id, direction: direction, paused: this._pause$.value, source });
            this.activeId = selectedSlide.id;
        }
        // we get here after the interval fires or any external API call like next(), prev() or select()
        this._cd.markForCheck();
    }
    /**
     * @private
     * @param {?} currentActiveSlideId
     * @param {?} nextActiveSlideId
     * @return {?}
     */
    _getSlideEventDirection(currentActiveSlideId, nextActiveSlideId) {
        /** @type {?} */
        const currentActiveSlideIdx = this._getSlideIdxById(currentActiveSlideId);
        /** @type {?} */
        const nextActiveSlideIdx = this._getSlideIdxById(nextActiveSlideId);
        return currentActiveSlideIdx > nextActiveSlideIdx ? NgbSlideEventDirection.RIGHT : NgbSlideEventDirection.LEFT;
    }
    /**
     * @private
     * @param {?} slideId
     * @return {?}
     */
    _getSlideById(slideId) { return this.slides.find((/**
     * @param {?} slide
     * @return {?}
     */
    slide => slide.id === slideId)); }
    /**
     * @private
     * @param {?} slideId
     * @return {?}
     */
    _getSlideIdxById(slideId) {
        return this.slides.toArray().indexOf(this._getSlideById(slideId));
    }
    /**
     * @private
     * @param {?} currentSlideId
     * @return {?}
     */
    _getNextSlide(currentSlideId) {
        /** @type {?} */
        const slideArr = this.slides.toArray();
        /** @type {?} */
        const currentSlideIdx = this._getSlideIdxById(currentSlideId);
        /** @type {?} */
        const isLastSlide = currentSlideIdx === slideArr.length - 1;
        return isLastSlide ? (this.wrap ? slideArr[0].id : slideArr[slideArr.length - 1].id) :
            slideArr[currentSlideIdx + 1].id;
    }
    /**
     * @private
     * @param {?} currentSlideId
     * @return {?}
     */
    _getPrevSlide(currentSlideId) {
        /** @type {?} */
        const slideArr = this.slides.toArray();
        /** @type {?} */
        const currentSlideIdx = this._getSlideIdxById(currentSlideId);
        /** @type {?} */
        const isFirstSlide = currentSlideIdx === 0;
        return isFirstSlide ? (this.wrap ? slideArr[slideArr.length - 1].id : slideArr[0].id) :
            slideArr[currentSlideIdx - 1].id;
    }
}
NgbCarousel.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NgbCarousel, selectors: [["ngb-carousel"]], factory: function NgbCarousel_Factory(t) { return new (t || NgbCarousel)(ɵngcc0.ɵɵdirectiveInject(NgbCarouselConfig), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NgZone), ɵngcc0.ɵɵdirectiveInject(ChangeDetectorRef)); }, contentQueries: function NgbCarousel_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgbSlide, false, null);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx.slides = _t);
    } }, hostBindings: function NgbCarousel_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowLeft", function NgbCarousel_keydown_arrowLeft_HostBindingHandler($event) { return ctx.keyboard && ctx.prev(ctx.NgbSlideEventSource.ARROW_LEFT); });
        ɵngcc0.ɵɵlistener("keydown.arrowRight", function NgbCarousel_keydown_arrowRight_HostBindingHandler($event) { return ctx.keyboard && ctx.next(ctx.NgbSlideEventSource.ARROW_RIGHT); });
        ɵngcc0.ɵɵlistener("mouseenter", function NgbCarousel_mouseenter_HostBindingHandler($event) { return ctx.mouseEnter(); });
        ɵngcc0.ɵɵlistener("mouseleave", function NgbCarousel_mouseleave_HostBindingHandler($event) { return ctx.mouseLeave(); });
        ɵngcc0.ɵɵelementHostAttrs(_c0);
        ɵngcc0.ɵɵstyling(null, _c1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp(0, "block");
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { interval: "interval", wrap: "wrap", keyboard: "keyboard", pauseOnHover: "pauseOnHover", showNavigationArrows: "showNavigationArrows", showNavigationIndicators: "showNavigationIndicators", activeId: "activeId" }, outputs: { slide: "slide" }, exportAs: ["ngbCarousel"], consts: 5, vars: 4, template: function NgbCarousel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NgbCarousel_ol_0_Template, 2, 1, "ol", _c2);
        ɵngcc0.ɵɵelementStart(1, "div", _c3);
        ɵngcc0.ɵɵtemplate(2, NgbCarousel_div_2_Template, 2, 1, "div", _c4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NgbCarousel_a_3_Template, 4, 0, "a", _c5);
        ɵngcc0.ɵɵtemplate(4, NgbCarousel_a_4_Template, 4, 0, "a", _c6);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.showNavigationIndicators);
        ɵngcc0.ɵɵselect(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.slides);
        ɵngcc0.ɵɵselect(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showNavigationArrows);
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showNavigationArrows);
    } }, directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf, ɵngcc1.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgbCarousel, [{
        type: Component,
        args: [{
                selector: 'ngb-carousel',
                exportAs: 'ngbCarousel',
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    'class': 'carousel slide',
                    '[style.display]': '"block"',
                    'tabIndex': '0',
                    '(keydown.arrowLeft)': 'keyboard && prev(NgbSlideEventSource.ARROW_LEFT)',
                    '(keydown.arrowRight)': 'keyboard && next(NgbSlideEventSource.ARROW_RIGHT)'
                },
                template: `
    <ol class="carousel-indicators" *ngIf="showNavigationIndicators">
      <li *ngFor="let slide of slides" [id]="slide.id" [class.active]="slide.id === activeId"
          (click)="select(slide.id, NgbSlideEventSource.INDICATOR)"></li>
    </ol>
    <div class="carousel-inner">
      <div *ngFor="let slide of slides" class="carousel-item" [class.active]="slide.id === activeId">
        <ng-template [ngTemplateOutlet]="slide.tplRef"></ng-template>
      </div>
    </div>
    <a class="carousel-control-prev" role="button" (click)="prev(NgbSlideEventSource.ARROW_LEFT)" *ngIf="showNavigationArrows">
      <span class="carousel-control-prev-icon" aria-hidden="true"></span>
      <span class="sr-only" i18n="@@ngb.carousel.previous">Previous</span>
    </a>
    <a class="carousel-control-next" role="button" (click)="next(NgbSlideEventSource.ARROW_RIGHT)" *ngIf="showNavigationArrows">
      <span class="carousel-control-next-icon" aria-hidden="true"></span>
      <span class="sr-only" i18n="@@ngb.carousel.next">Next</span>
    </a>
  `
            }]
    }], function () { return [{ type: NgbCarouselConfig }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: NgZone }, { type: ChangeDetectorRef }]; }, { constructor: [], _platformId: [], _ngZone: [], _cd: [], NgbSlideEventSource: [], _destroy$: [], _interval$: [], _mouseHover$: [], _pauseOnHover$: [], _pause$: [], _wrap$: [], slide: [{
            type: Output
        }], interval: [{
            type: Input
        }], interval: [], wrap: [{
            type: Input
        }], wrap: [], keyboard: [{
            type: Input
        }], pauseOnHover: [{
            type: Input
        }], pauseOnHover: [], showNavigationArrows: [{
            type: Input
        }], showNavigationIndicators: [{
            type: Input
        }], mouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], mouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], ngAfterContentInit: [], ngAfterContentChecked: [], activeId: [{
            type: Input
        }], ngOnDestroy: [], select: [], prev: [], next: [], pause: [], cycle: [], _cycleToSelected: [], _getSlideEventDirection: [], _getSlideById: [], _getSlideIdxById: [], _getNextSlide: [], _getPrevSlide: [], slides: [{
            type: ContentChildren,
            args: [NgbSlide]
        }] });
/** @nocollapse */
NgbCarousel.ctorParameters = () => [
    { type: NgbCarouselConfig },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
NgbCarousel.propDecorators = {
    slides: [{ type: ContentChildren, args: [NgbSlide,] }],
    activeId: [{ type: Input }],
    interval: [{ type: Input }],
    wrap: [{ type: Input }],
    keyboard: [{ type: Input }],
    pauseOnHover: [{ type: Input }],
    showNavigationArrows: [{ type: Input }],
    showNavigationIndicators: [{ type: Input }],
    slide: [{ type: Output }],
    mouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
    mouseLeave: [{ type: HostListener, args: ['mouseleave',] }]
};
if (false) {
    /** @type {?} */
    NgbCarousel.prototype.slides;
    /** @type {?} */
    NgbCarousel.prototype.NgbSlideEventSource;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._destroy$;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._interval$;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._mouseHover$;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._pauseOnHover$;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._pause$;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._wrap$;
    /**
     * The slide id that should be displayed **initially**.
     *
     * For subsequent interactions use methods `select()`, `next()`, etc. and the `(slide)` output.
     * @type {?}
     */
    NgbCarousel.prototype.activeId;
    /**
     * If `true`, allows to interact with carousel using keyboard 'arrow left' and 'arrow right'.
     * @type {?}
     */
    NgbCarousel.prototype.keyboard;
    /**
     * If `true`, 'previous' and 'next' navigation arrows will be visible on the slide.
     *
     * \@since 2.2.0
     * @type {?}
     */
    NgbCarousel.prototype.showNavigationArrows;
    /**
     * If `true`, navigation indicators at the bottom of the slide will be visible.
     *
     * \@since 2.2.0
     * @type {?}
     */
    NgbCarousel.prototype.showNavigationIndicators;
    /**
     * An event emitted right after the slide transition is completed.
     *
     * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.
     * @type {?}
     */
    NgbCarousel.prototype.slide;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._platformId;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    NgbCarousel.prototype._cd;
}
/**
 * A slide change event emitted right after the slide transition is completed.
 * @record
 */
export function NgbSlideEvent() { }
if (false) {
    /**
     * The previous slide id.
     * @type {?}
     */
    NgbSlideEvent.prototype.prev;
    /**
     * The current slide id.
     * @type {?}
     */
    NgbSlideEvent.prototype.current;
    /**
     * The slide event direction.
     *
     * Possible values are `'left' | 'right'`.
     * @type {?}
     */
    NgbSlideEvent.prototype.direction;
    /**
     * Whether the pause() method was called (and no cycle() call was done afterwards).
     *
     * \@since 5.1.0
     * @type {?}
     */
    NgbSlideEvent.prototype.paused;
    /**
     * Source triggering the slide change event.
     *
     * Possible values are `'timer' | 'arrowLeft' | 'arrowRight' | 'indicator'`
     *
     * \@since 5.1.0
     * @type {?|undefined}
     */
    NgbSlideEvent.prototype.source;
}
/** @enum {string} */
const NgbSlideEventDirection = {
    LEFT: (/** @type {?} */ ('left')),
    RIGHT: (/** @type {?} */ ('right')),
};
export { NgbSlideEventDirection };
/** @enum {string} */
const NgbSlideEventSource = {
    TIMER: 'timer',
    ARROW_LEFT: 'arrowLeft',
    ARROW_RIGHT: 'arrowRight',
    INDICATOR: 'indicator',
};
export { NgbSlideEventSource };
/** @type {?} */
export const NGB_CAROUSEL_DIRECTIVES = [NgbCarousel, NgbSlide];

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L3BhdHJvbmVzL3BhdHJvbmVzU2lkZXJjYVdlYi9Gcm9udGVuZC9ub2RlX21vZHVsZXMvQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAvZXNtMjAxNS9jYXJvdXNlbC9jYXJvdXNlbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsYUFHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMFJELGFBaUNDIiwiZmlsZSI6ImNhcm91c2VsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBJbmplY3QsIElucHV0LCBOZ1pvbmUsIE91dHB1dCwgUExBVEZPUk1fSUQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdiQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuL2Nhcm91c2VsLWNvbmZpZyc7XG5pbXBvcnQgeyBTdWJqZWN0LCB0aW1lciwgQmVoYXZpb3JTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBORVZFUiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3RhcnRXaXRoLCBtYXAsIHN3aXRjaE1hcCwgdGFrZVVudGlsLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbi8qKiBAdHlwZSB7P30gKi9cbmxldCBuZXh0SWQgPSAwO1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHdyYXBzIHRoZSBpbmRpdmlkdWFsIGNhcm91c2VsIHNsaWRlLlxuICovXG5leHBvcnQgY2xhc3MgTmdiU2xpZGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHBsUmVmXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHBsUmVmKSB7XG4gICAgICAgIHRoaXMudHBsUmVmID0gdHBsUmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2xpZGUgaWQgdGhhdCBtdXN0IGJlIHVuaXF1ZSBmb3IgdGhlIGVudGlyZSBkb2N1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm90IHByb3ZpZGVkLCB3aWxsIGJlIGdlbmVyYXRlZCBpbiB0aGUgYG5nYi1zbGlkZS14eGAgZm9ybWF0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IGBuZ2Itc2xpZGUtJHtuZXh0SWQrK31gO1xuICAgIH1cbn1cbk5nYlNsaWRlLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBEaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbmdiU2xpZGVdJyB9LF0gfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuTmdiU2xpZGUuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVJlZiB9XG5dO1xuTmdiU2xpZGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgaWQ6IFt7IHR5cGU6IElucHV0IH1dXG59O1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogU2xpZGUgaWQgdGhhdCBtdXN0IGJlIHVuaXF1ZSBmb3IgdGhlIGVudGlyZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIElmIG5vdCBwcm92aWRlZCwgd2lsbCBiZSBnZW5lcmF0ZWQgaW4gdGhlIGBuZ2Itc2xpZGUteHhgIGZvcm1hdC5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JTbGlkZS5wcm90b3R5cGUuaWQ7XG4gICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgIE5nYlNsaWRlLnByb3RvdHlwZS50cGxSZWY7XG59XG4vKipcbiAqIENhcm91c2VsIGlzIGEgY29tcG9uZW50IHRvIGVhc2lseSBjcmVhdGUgYW5kIGNvbnRyb2wgc2xpZGVzaG93cy5cbiAqXG4gKiBBbGxvd3MgdG8gc2V0IGludGVydmFscywgY2hhbmdlIHRoZSB3YXkgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgc2xpZGVzIGFuZCBwcm92aWRlcyBhIHByb2dyYW1tYXRpYyBBUEkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZ2JDYXJvdXNlbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcGFyYW0gez99IF9wbGF0Zm9ybUlkXG4gICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICogQHBhcmFtIHs/fSBfY2RcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIF9wbGF0Zm9ybUlkLCBfbmdab25lLCBfY2QpIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm1JZCA9IF9wbGF0Zm9ybUlkO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9jZCA9IF9jZDtcbiAgICAgICAgdGhpcy5OZ2JTbGlkZUV2ZW50U291cmNlID0gTmdiU2xpZGVFdmVudFNvdXJjZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KDApO1xuICAgICAgICB0aGlzLl9tb3VzZUhvdmVyJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICAgICAgICB0aGlzLl9wYXVzZU9uSG92ZXIkID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gICAgICAgIHRoaXMuX3BhdXNlJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICAgICAgICB0aGlzLl93cmFwJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZXZlbnQgZW1pdHRlZCByaWdodCBhZnRlciB0aGUgc2xpZGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSBbYE5nYlNsaWRlRXZlbnRgXSgjL2NvbXBvbmVudHMvY2Fyb3VzZWwvYXBpI05nYlNsaWRlRXZlbnQpIGZvciBwYXlsb2FkIGRldGFpbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNsaWRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gY29uZmlnLmludGVydmFsO1xuICAgICAgICB0aGlzLndyYXAgPSBjb25maWcud3JhcDtcbiAgICAgICAgdGhpcy5rZXlib2FyZCA9IGNvbmZpZy5rZXlib2FyZDtcbiAgICAgICAgdGhpcy5wYXVzZU9uSG92ZXIgPSBjb25maWcucGF1c2VPbkhvdmVyO1xuICAgICAgICB0aGlzLnNob3dOYXZpZ2F0aW9uQXJyb3dzID0gY29uZmlnLnNob3dOYXZpZ2F0aW9uQXJyb3dzO1xuICAgICAgICB0aGlzLnNob3dOYXZpZ2F0aW9uSW5kaWNhdG9ycyA9IGNvbmZpZy5zaG93TmF2aWdhdGlvbkluZGljYXRvcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgbmV4dCBzbGlkZSBpcyBzaG93bi5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXQgaW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwkLm5leHQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBpbnRlcnZhbCgpIHsgcmV0dXJuIHRoaXMuX2ludGVydmFsJC52YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgd2lsbCAnd3JhcCcgdGhlIGNhcm91c2VsIGJ5IHN3aXRjaGluZyBmcm9tIHRoZSBsYXN0IHNsaWRlIGJhY2sgdG8gdGhlIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCB3cmFwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dyYXAkLm5leHQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCB3cmFwKCkgeyByZXR1cm4gdGhpcy5fd3JhcCQudmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsIHdpbGwgcGF1c2Ugc2xpZGUgc3dpdGNoaW5nIHdoZW4gbW91c2UgY3Vyc29yIGhvdmVycyB0aGUgc2xpZGUuXG4gICAgICpcbiAgICAgKiBcXEBzaW5jZSAyLjIuMFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldCBwYXVzZU9uSG92ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VPbkhvdmVyJC5uZXh0KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXQgcGF1c2VPbkhvdmVyKCkgeyByZXR1cm4gdGhpcy5fcGF1c2VPbkhvdmVyJC52YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbW91c2VFbnRlcigpIHtcbiAgICAgICAgdGhpcy5fbW91c2VIb3ZlciQubmV4dCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBtb3VzZUxlYXZlKCkge1xuICAgICAgICB0aGlzLl9tb3VzZUhvdmVyJC5uZXh0KGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIC8vIHNldEludGVydmFsKCkgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBTU1IgYW5kIHByb3RyYWN0b3IsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBydW4gaXQgaW4gdGhlIGJyb3dzZXIgYW5kIG91dHNpZGUgQW5ndWxhclxuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm1JZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc05leHRTbGlkZSQgPSBjb21iaW5lTGF0ZXN0KHRoaXMuc2xpZGUucGlwZShtYXAoKC8qKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gc2xpZGVFdmVudFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2xpZGVFdmVudCA9PiBzbGlkZUV2ZW50LmN1cnJlbnQpKSwgc3RhcnRXaXRoKHRoaXMuYWN0aXZlSWQpKSwgdGhpcy5fd3JhcCQsIHRoaXMuc2xpZGVzLmNoYW5nZXMucGlwZShzdGFydFdpdGgobnVsbCkpKVxuICAgICAgICAgICAgICAgICAgICAucGlwZShtYXAoKC8qKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAoW2N1cnJlbnRTbGlkZUlkLCB3cmFwXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsaWRlQXJyID0gdGhpcy5zbGlkZXMudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZUlkeCA9IHRoaXMuX2dldFNsaWRlSWR4QnlJZChjdXJyZW50U2xpZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwID8gc2xpZGVBcnIubGVuZ3RoID4gMSA6IGN1cnJlbnRTbGlkZUlkeCA8IHNsaWRlQXJyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgICAgICAgICBjb21iaW5lTGF0ZXN0KHRoaXMuX3BhdXNlJCwgdGhpcy5fcGF1c2VPbkhvdmVyJCwgdGhpcy5fbW91c2VIb3ZlciQsIHRoaXMuX2ludGVydmFsJCwgaGFzTmV4dFNsaWRlJClcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUobWFwKCgvKipcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IF9fMFxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgKFtwYXVzZSwgcGF1c2VPbkhvdmVyLCBtb3VzZUhvdmVyLCBpbnRlcnZhbCwgaGFzTmV4dFNsaWRlXSkgPT4gKChwYXVzZSB8fCAocGF1c2VPbkhvdmVyICYmIG1vdXNlSG92ZXIpIHx8ICFoYXNOZXh0U2xpZGUpID8gMCA6IGludGVydmFsKSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLCBzd2l0Y2hNYXAoKC8qKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7P30gaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGludGVydmFsID0+IGludGVydmFsID4gMCA/IHRpbWVyKGludGVydmFsLCBpbnRlcnZhbCkgOiBORVZFUikpLCB0YWtlVW50aWwodGhpcy5fZGVzdHJveSQpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgvKipcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICgpID0+IHRoaXMuX25nWm9uZS5ydW4oKC8qKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5uZXh0KE5nYlNsaWRlRXZlbnRTb3VyY2UuVElNRVIpKSkpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNsaWRlcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSkuc3Vic2NyaWJlKCgvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICgpID0+IHRoaXMuX2NkLm1hcmtGb3JDaGVjaygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGxldCBhY3RpdmVTbGlkZSA9IHRoaXMuX2dldFNsaWRlQnlJZCh0aGlzLmFjdGl2ZUlkKTtcbiAgICAgICAgdGhpcy5hY3RpdmVJZCA9IGFjdGl2ZVNsaWRlID8gYWN0aXZlU2xpZGUuaWQgOiAodGhpcy5zbGlkZXMubGVuZ3RoID8gdGhpcy5zbGlkZXMuZmlyc3QuaWQgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHsgdGhpcy5fZGVzdHJveSQubmV4dCgpOyB9XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIGEgc2xpZGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIHs/fSBzbGlkZUlkXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZWxlY3Qoc2xpZGVJZCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuX2N5Y2xlVG9TZWxlY3RlZChzbGlkZUlkLCB0aGlzLl9nZXRTbGlkZUV2ZW50RGlyZWN0aW9uKHRoaXMuYWN0aXZlSWQsIHNsaWRlSWQpLCBzb3VyY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gdGhlIHByZXZpb3VzIHNsaWRlLlxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgcHJldihzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fY3ljbGVUb1NlbGVjdGVkKHRoaXMuX2dldFByZXZTbGlkZSh0aGlzLmFjdGl2ZUlkKSwgTmdiU2xpZGVFdmVudERpcmVjdGlvbi5SSUdIVCwgc291cmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIHRoZSBuZXh0IHNsaWRlLlxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgbmV4dChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fY3ljbGVUb1NlbGVjdGVkKHRoaXMuX2dldE5leHRTbGlkZSh0aGlzLmFjdGl2ZUlkKSwgTmdiU2xpZGVFdmVudERpcmVjdGlvbi5MRUZULCBzb3VyY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgY3ljbGluZyB0aHJvdWdoIHRoZSBzbGlkZXMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBwYXVzZSgpIHsgdGhpcy5fcGF1c2UkLm5leHQodHJ1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBSZXN0YXJ0cyBjeWNsaW5nIHRocm91Z2ggdGhlIHNsaWRlcyBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBjeWNsZSgpIHsgdGhpcy5fcGF1c2UkLm5leHQoZmFsc2UpOyB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHNsaWRlSWR4XG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9jeWNsZVRvU2VsZWN0ZWQoc2xpZGVJZHgsIGRpcmVjdGlvbiwgc291cmNlKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgbGV0IHNlbGVjdGVkU2xpZGUgPSB0aGlzLl9nZXRTbGlkZUJ5SWQoc2xpZGVJZHgpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRTbGlkZSAmJiBzZWxlY3RlZFNsaWRlLmlkICE9PSB0aGlzLmFjdGl2ZUlkKSB7XG4gICAgICAgICAgICB0aGlzLnNsaWRlLmVtaXQoeyBwcmV2OiB0aGlzLmFjdGl2ZUlkLCBjdXJyZW50OiBzZWxlY3RlZFNsaWRlLmlkLCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgcGF1c2VkOiB0aGlzLl9wYXVzZSQudmFsdWUsIHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSWQgPSBzZWxlY3RlZFNsaWRlLmlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGdldCBoZXJlIGFmdGVyIHRoZSBpbnRlcnZhbCBmaXJlcyBvciBhbnkgZXh0ZXJuYWwgQVBJIGNhbGwgbGlrZSBuZXh0KCksIHByZXYoKSBvciBzZWxlY3QoKVxuICAgICAgICB0aGlzLl9jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRBY3RpdmVTbGlkZUlkXG4gICAgICogQHBhcmFtIHs/fSBuZXh0QWN0aXZlU2xpZGVJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2dldFNsaWRlRXZlbnREaXJlY3Rpb24oY3VycmVudEFjdGl2ZVNsaWRlSWQsIG5leHRBY3RpdmVTbGlkZUlkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgY3VycmVudEFjdGl2ZVNsaWRlSWR4ID0gdGhpcy5fZ2V0U2xpZGVJZHhCeUlkKGN1cnJlbnRBY3RpdmVTbGlkZUlkKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBuZXh0QWN0aXZlU2xpZGVJZHggPSB0aGlzLl9nZXRTbGlkZUlkeEJ5SWQobmV4dEFjdGl2ZVNsaWRlSWQpO1xuICAgICAgICByZXR1cm4gY3VycmVudEFjdGl2ZVNsaWRlSWR4ID4gbmV4dEFjdGl2ZVNsaWRlSWR4ID8gTmdiU2xpZGVFdmVudERpcmVjdGlvbi5SSUdIVCA6IE5nYlNsaWRlRXZlbnREaXJlY3Rpb24uTEVGVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHNsaWRlSWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9nZXRTbGlkZUJ5SWQoc2xpZGVJZCkgeyByZXR1cm4gdGhpcy5zbGlkZXMuZmluZCgoLyoqXG4gICAgICogQHBhcmFtIHs/fSBzbGlkZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc2xpZGUgPT4gc2xpZGUuaWQgPT09IHNsaWRlSWQpKTsgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBzbGlkZUlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfZ2V0U2xpZGVJZHhCeUlkKHNsaWRlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzLnRvQXJyYXkoKS5pbmRleE9mKHRoaXMuX2dldFNsaWRlQnlJZChzbGlkZUlkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50U2xpZGVJZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX2dldE5leHRTbGlkZShjdXJyZW50U2xpZGVJZCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IHNsaWRlQXJyID0gdGhpcy5zbGlkZXMudG9BcnJheSgpO1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbGlkZUlkeCA9IHRoaXMuX2dldFNsaWRlSWR4QnlJZChjdXJyZW50U2xpZGVJZCk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgaXNMYXN0U2xpZGUgPSBjdXJyZW50U2xpZGVJZHggPT09IHNsaWRlQXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBpc0xhc3RTbGlkZSA/ICh0aGlzLndyYXAgPyBzbGlkZUFyclswXS5pZCA6IHNsaWRlQXJyW3NsaWRlQXJyLmxlbmd0aCAtIDFdLmlkKSA6XG4gICAgICAgICAgICBzbGlkZUFycltjdXJyZW50U2xpZGVJZHggKyAxXS5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRTbGlkZUlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfZ2V0UHJldlNsaWRlKGN1cnJlbnRTbGlkZUlkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3Qgc2xpZGVBcnIgPSB0aGlzLnNsaWRlcy50b0FycmF5KCk7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgY29uc3QgY3VycmVudFNsaWRlSWR4ID0gdGhpcy5fZ2V0U2xpZGVJZHhCeUlkKGN1cnJlbnRTbGlkZUlkKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICBjb25zdCBpc0ZpcnN0U2xpZGUgPSBjdXJyZW50U2xpZGVJZHggPT09IDA7XG4gICAgICAgIHJldHVybiBpc0ZpcnN0U2xpZGUgPyAodGhpcy53cmFwID8gc2xpZGVBcnJbc2xpZGVBcnIubGVuZ3RoIC0gMV0uaWQgOiBzbGlkZUFyclswXS5pZCkgOlxuICAgICAgICAgICAgc2xpZGVBcnJbY3VycmVudFNsaWRlSWR4IC0gMV0uaWQ7XG4gICAgfVxufVxuTmdiQ2Fyb3VzZWwuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBvbmVudCwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ25nYi1jYXJvdXNlbCcsXG4gICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ2JDYXJvdXNlbCcsXG4gICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnY2Fyb3VzZWwgc2xpZGUnLFxuICAgICAgICAgICAgICAgICAgICAnW3N0eWxlLmRpc3BsYXldJzogJ1wiYmxvY2tcIicsXG4gICAgICAgICAgICAgICAgICAgICd0YWJJbmRleCc6ICcwJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLmFycm93TGVmdCknOiAna2V5Ym9hcmQgJiYgcHJldihOZ2JTbGlkZUV2ZW50U291cmNlLkFSUk9XX0xFRlQpJyxcbiAgICAgICAgICAgICAgICAgICAgJyhrZXlkb3duLmFycm93UmlnaHQpJzogJ2tleWJvYXJkICYmIG5leHQoTmdiU2xpZGVFdmVudFNvdXJjZS5BUlJPV19SSUdIVCknXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxvbCBjbGFzcz1cImNhcm91c2VsLWluZGljYXRvcnNcIiAqbmdJZj1cInNob3dOYXZpZ2F0aW9uSW5kaWNhdG9yc1wiPlxuICAgICAgPGxpICpuZ0Zvcj1cImxldCBzbGlkZSBvZiBzbGlkZXNcIiBbaWRdPVwic2xpZGUuaWRcIiBbY2xhc3MuYWN0aXZlXT1cInNsaWRlLmlkID09PSBhY3RpdmVJZFwiXG4gICAgICAgICAgKGNsaWNrKT1cInNlbGVjdChzbGlkZS5pZCwgTmdiU2xpZGVFdmVudFNvdXJjZS5JTkRJQ0FUT1IpXCI+PC9saT5cbiAgICA8L29sPlxuICAgIDxkaXYgY2xhc3M9XCJjYXJvdXNlbC1pbm5lclwiPlxuICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgc2xpZGUgb2Ygc2xpZGVzXCIgY2xhc3M9XCJjYXJvdXNlbC1pdGVtXCIgW2NsYXNzLmFjdGl2ZV09XCJzbGlkZS5pZCA9PT0gYWN0aXZlSWRcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInNsaWRlLnRwbFJlZlwiPjwvbmctdGVtcGxhdGU+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8YSBjbGFzcz1cImNhcm91c2VsLWNvbnRyb2wtcHJldlwiIHJvbGU9XCJidXR0b25cIiAoY2xpY2spPVwicHJldihOZ2JTbGlkZUV2ZW50U291cmNlLkFSUk9XX0xFRlQpXCIgKm5nSWY9XCJzaG93TmF2aWdhdGlvbkFycm93c1wiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJjYXJvdXNlbC1jb250cm9sLXByZXYtaWNvblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwic3Itb25seVwiIGkxOG49XCJAQG5nYi5jYXJvdXNlbC5wcmV2aW91c1wiPlByZXZpb3VzPC9zcGFuPlxuICAgIDwvYT5cbiAgICA8YSBjbGFzcz1cImNhcm91c2VsLWNvbnRyb2wtbmV4dFwiIHJvbGU9XCJidXR0b25cIiAoY2xpY2spPVwibmV4dChOZ2JTbGlkZUV2ZW50U291cmNlLkFSUk9XX1JJR0hUKVwiICpuZ0lmPVwic2hvd05hdmlnYXRpb25BcnJvd3NcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiY2Fyb3VzZWwtY29udHJvbC1uZXh0LWljb25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIiBpMThuPVwiQEBuZ2IuY2Fyb3VzZWwubmV4dFwiPk5leHQ8L3NwYW4+XG4gICAgPC9hPlxuICBgXG4gICAgICAgICAgICB9XSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5OZ2JDYXJvdXNlbC5jdG9yUGFyYW1ldGVycyA9ICgpID0+IFtcbiAgICB7IHR5cGU6IE5nYkNhcm91c2VsQ29uZmlnIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IEluamVjdCwgYXJnczogW1BMQVRGT1JNX0lELF0gfV0gfSxcbiAgICB7IHR5cGU6IE5nWm9uZSB9LFxuICAgIHsgdHlwZTogQ2hhbmdlRGV0ZWN0b3JSZWYgfVxuXTtcbk5nYkNhcm91c2VsLnByb3BEZWNvcmF0b3JzID0ge1xuICAgIHNsaWRlczogW3sgdHlwZTogQ29udGVudENoaWxkcmVuLCBhcmdzOiBbTmdiU2xpZGUsXSB9XSxcbiAgICBhY3RpdmVJZDogW3sgdHlwZTogSW5wdXQgfV0sXG4gICAgaW50ZXJ2YWw6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHdyYXA6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIGtleWJvYXJkOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBwYXVzZU9uSG92ZXI6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNob3dOYXZpZ2F0aW9uQXJyb3dzOiBbeyB0eXBlOiBJbnB1dCB9XSxcbiAgICBzaG93TmF2aWdhdGlvbkluZGljYXRvcnM6IFt7IHR5cGU6IElucHV0IH1dLFxuICAgIHNsaWRlOiBbeyB0eXBlOiBPdXRwdXQgfV0sXG4gICAgbW91c2VFbnRlcjogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ21vdXNlZW50ZXInLF0gfV0sXG4gICAgbW91c2VMZWF2ZTogW3sgdHlwZTogSG9zdExpc3RlbmVyLCBhcmdzOiBbJ21vdXNlbGVhdmUnLF0gfV1cbn07XG5pZiAoZmFsc2UpIHtcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTmdiQ2Fyb3VzZWwucHJvdG90eXBlLnNsaWRlcztcbiAgICAvKiogQHR5cGUgez99ICovXG4gICAgTmdiQ2Fyb3VzZWwucHJvdG90eXBlLk5nYlNsaWRlRXZlbnRTb3VyY2U7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuX2Rlc3Ryb3kkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTmdiQ2Fyb3VzZWwucHJvdG90eXBlLl9pbnRlcnZhbCQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuX21vdXNlSG92ZXIkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTmdiQ2Fyb3VzZWwucHJvdG90eXBlLl9wYXVzZU9uSG92ZXIkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTmdiQ2Fyb3VzZWwucHJvdG90eXBlLl9wYXVzZSQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuX3dyYXAkO1xuICAgIC8qKlxuICAgICAqIFRoZSBzbGlkZSBpZCB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgKippbml0aWFsbHkqKi5cbiAgICAgKlxuICAgICAqIEZvciBzdWJzZXF1ZW50IGludGVyYWN0aW9ucyB1c2UgbWV0aG9kcyBgc2VsZWN0KClgLCBgbmV4dCgpYCwgZXRjLiBhbmQgdGhlIGAoc2xpZGUpYCBvdXRwdXQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdiQ2Fyb3VzZWwucHJvdG90eXBlLmFjdGl2ZUlkO1xuICAgIC8qKlxuICAgICAqIElmIGB0cnVlYCwgYWxsb3dzIHRvIGludGVyYWN0IHdpdGggY2Fyb3VzZWwgdXNpbmcga2V5Ym9hcmQgJ2Fycm93IGxlZnQnIGFuZCAnYXJyb3cgcmlnaHQnLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nYkNhcm91c2VsLnByb3RvdHlwZS5rZXlib2FyZDtcbiAgICAvKipcbiAgICAgKiBJZiBgdHJ1ZWAsICdwcmV2aW91cycgYW5kICduZXh0JyBuYXZpZ2F0aW9uIGFycm93cyB3aWxsIGJlIHZpc2libGUgb24gdGhlIHNsaWRlLlxuICAgICAqXG4gICAgICogXFxAc2luY2UgMi4yLjBcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuc2hvd05hdmlnYXRpb25BcnJvd3M7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBuYXZpZ2F0aW9uIGluZGljYXRvcnMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgc2xpZGUgd2lsbCBiZSB2aXNpYmxlLlxuICAgICAqXG4gICAgICogXFxAc2luY2UgMi4yLjBcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuc2hvd05hdmlnYXRpb25JbmRpY2F0b3JzO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYWZ0ZXIgdGhlIHNsaWRlIHRyYW5zaXRpb24gaXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogU2VlIFtgTmdiU2xpZGVFdmVudGBdKCMvY29tcG9uZW50cy9jYXJvdXNlbC9hcGkjTmdiU2xpZGVFdmVudCkgZm9yIHBheWxvYWQgZGV0YWlscy5cbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuc2xpZGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuX3BsYXRmb3JtSWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOZ2JDYXJvdXNlbC5wcm90b3R5cGUuX25nWm9uZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE5nYkNhcm91c2VsLnByb3RvdHlwZS5fY2Q7XG59XG4vKipcbiAqIEEgc2xpZGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgcmlnaHQgYWZ0ZXIgdGhlIHNsaWRlIHRyYW5zaXRpb24gaXMgY29tcGxldGVkLlxuICogQHJlY29yZFxuICovXG5leHBvcnQgZnVuY3Rpb24gTmdiU2xpZGVFdmVudCgpIHsgfVxuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHNsaWRlIGlkLlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nYlNsaWRlRXZlbnQucHJvdG90eXBlLnByZXY7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc2xpZGUgaWQuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdiU2xpZGVFdmVudC5wcm90b3R5cGUuY3VycmVudDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2xpZGUgZXZlbnQgZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ2xlZnQnIHwgJ3JpZ2h0J2AuXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgTmdiU2xpZGVFdmVudC5wcm90b3R5cGUuZGlyZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHBhdXNlKCkgbWV0aG9kIHdhcyBjYWxsZWQgKGFuZCBubyBjeWNsZSgpIGNhbGwgd2FzIGRvbmUgYWZ0ZXJ3YXJkcykuXG4gICAgICpcbiAgICAgKiBcXEBzaW5jZSA1LjEuMFxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqL1xuICAgIE5nYlNsaWRlRXZlbnQucHJvdG90eXBlLnBhdXNlZDtcbiAgICAvKipcbiAgICAgKiBTb3VyY2UgdHJpZ2dlcmluZyB0aGUgc2xpZGUgY2hhbmdlIGV2ZW50LlxuICAgICAqXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ3RpbWVyJyB8ICdhcnJvd0xlZnQnIHwgJ2Fycm93UmlnaHQnIHwgJ2luZGljYXRvcidgXG4gICAgICpcbiAgICAgKiBcXEBzaW5jZSA1LjEuMFxuICAgICAqIEB0eXBlIHs/fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBOZ2JTbGlkZUV2ZW50LnByb3RvdHlwZS5zb3VyY2U7XG59XG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IE5nYlNsaWRlRXZlbnREaXJlY3Rpb24gPSB7XG4gICAgTEVGVDogKC8qKiBAdHlwZSB7P30gKi8gKCdsZWZ0JykpLFxuICAgIFJJR0hUOiAoLyoqIEB0eXBlIHs/fSAqLyAoJ3JpZ2h0JykpLFxufTtcbmV4cG9ydCB7IE5nYlNsaWRlRXZlbnREaXJlY3Rpb24gfTtcbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgTmdiU2xpZGVFdmVudFNvdXJjZSA9IHtcbiAgICBUSU1FUjogJ3RpbWVyJyxcbiAgICBBUlJPV19MRUZUOiAnYXJyb3dMZWZ0JyxcbiAgICBBUlJPV19SSUdIVDogJ2Fycm93UmlnaHQnLFxuICAgIElORElDQVRPUjogJ2luZGljYXRvcicsXG59O1xuZXhwb3J0IHsgTmdiU2xpZGVFdmVudFNvdXJjZSB9O1xuLyoqIEB0eXBlIHs/fSAqL1xuZXhwb3J0IGNvbnN0IE5HQl9DQVJPVVNFTF9ESVJFQ1RJVkVTID0gW05nYkNhcm91c2VsLCBOZ2JTbGlkZV07XG4iXX0=